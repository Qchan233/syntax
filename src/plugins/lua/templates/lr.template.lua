--[[
  LR parser for Example language generated by the Syntax tool.
 
  https://www.npmjs.com/package/syntax-cli
 
    npm install -g syntax-cli
 
    syntax-cli --help
 
  To regenerate run:
 
    syntax-cli \
      --grammar ~/path-to-grammar-file \
      --mode <parsing-mode> \
      --output ~/ParserClassName.lua
--]]

--[[ 
usage:
  Parser = require("ParserClassName")
  parser = Parser.new()
  print(parser:parse("<input>"))
--]]

local EOF = "$"

{{{TOKENIZER}}}

local productions = {{{PRODUCTIONS}}}

local parsing_table = {{{TABLE}}}

localstack = {}

local __ = nil

local __loc = nil

function yyloc(startLoc, endLoc)
  if not shouldCaptureLocations then
    return nil
  end

  if not startLoc or not endLoc then
    return startLoc or endLoc
  end

  return {
    startOffset = startLoc.startOffset,
    endOffset = endLoc.endOffset,
    startLine = startLoc.startLine,
    endLine = endLoc.endLine,
    startColumn = startLoc.startColumn,
    endColumn = endLoc.endColumn,
  }
end

local shouldCaptureLocations = {{{CAPTURE_LOCATIONS}}}

local function StackEntry(params)
  local entry = {
    symbol = params.symbol,
    semanticValue = params.semanticValue,
    loc = params.loc,
  }
  return entry
end

local function yyparse()
  local parser = {}
  
  parser.tokenizer = Tokenizer:new()

  function parser:onParseBegin() 
  end

  function parser:onParseEnd() 
  end

  {{{PRODUCTION_HANDLERS}}}

  function parser:setOptions(options)
    if options.captureLocations ~= nil then
      shouldCaptureLocations = options.captureLocations
    end
    return self
  end

  function parser:parse(str)
    self:onParseBegin(str)

    if not self.tokenizer then
      error("Tokenizer instance isn't specified.")
    end

    self.tokenizer:initString(str)

    stack = {0}

    local token = self.tokenizer:getNextToken()
    local shiftedToken = nil

    repeat
      if not token then
        self:unexpectedEndOfInput()
      end

      local state = tonumber(stack[#stack])
      local column = token.type
      local entry = parsing_table[state + 1][column]

      if not entry then
        self:unexpectedToken(token)
      end

      if entry:sub(1,1) == 's' then
        local loc = nil

        if shouldCaptureLocations then
          loc = {
            startOffset = token.startOffset,
            endOffset = token.endOffset,
            startLine = token.startLine,
            endLine = token.endLine,
            startColumn = token.startColumn,
            endColumn = token.endColumn,
          }
        end

        table.insert(stack, StackEntry({
          symbol = token.type,
          semanticValue = token.value,
          loc = loc,
        }))

        table.insert(stack, tonumber(entry:sub(2)))

        shiftedToken = token
        token = self.tokenizer:getNextToken()

      elseif entry:sub(1,1) == 'r' then
        local productionNumber = tonumber(entry:sub(2))
        local production = productions[productionNumber + 1]

        local hasSemanticAction = #production > 2

        local semanticValueArgs = hasSemanticAction and {} or nil

        local locationArgs = (
          hasSemanticAction and shouldCaptureLocations
            and {} or nil
        )

        local rhsLength = tonumber(production[2])
        if rhsLength ~= 0 then
          while rhsLength > 0 do
            table.remove(stack)

            local stackEntry = table.remove(stack)

            if hasSemanticAction then
              table.insert(semanticValueArgs, 1, stackEntry.semanticValue)

              if locationArgs then
                table.insert(locationArgs, 1, stackEntry.loc)
              end
            end
            rhsLength = rhsLength - 1
          end
        end

        local previousState = tonumber(stack[#stack])

        local symbolToReduceWith = tostring(production[1])

        local reduceStackEntry = StackEntry({
          symbol = symbolToReduceWith,
          semanticValue = nil,
          loc = nil,
        })

        if hasSemanticAction then
          yytext = shiftedToken and shiftedToken.value or nil
          yyleng = shiftedToken and #shiftedToken.value or 0

          local semanticActionName = production[3]
          local semanticActionHandler = self[semanticActionName]

          local semanticActionArgs = {}
          if locationArgs then
            for _, v in ipairs(semanticValueArgs) do
              table.insert(semanticActionArgs, v)
            end
            for _, v in ipairs(locationArgs) do
              table.insert(semanticActionArgs, v)
            end
          else
            for _, v in ipairs(semanticValueArgs) do
              table.insert(semanticActionArgs, v)
            end
          end

          semanticActionHandler(self, table.unpack(semanticActionArgs))

          reduceStackEntry.semanticValue = __

          if locationArgs then
            reduceStackEntry.loc = __loc
          end
        end

        table.insert(stack, reduceStackEntry)

        local nextState = parsing_table[previousState + 1][symbolToReduceWith]
        table.insert(stack, nextState)

      elseif entry == "acc" then
        table.remove(stack)

        local parsed = table.remove(stack)

        if #stack ~= 1 or
           stack[#stack] ~= 0 or
           self.tokenizer:hasMoreTokens() then
            self:unexpectedToken(token)
        end

        local parsedValue = parsed.semanticValue
        self:onParseEnd(parsedValue)

        return parsedValue
      end

    until not (self.tokenizer:hasMoreTokens() or #stack > 1)

    return nil
  end

  function parser:unexpectedToken(token)
    if token.type == EOF then
      self:unexpectedEndOfInput()
    end

    self.tokenizer:throwUnexpectedToken(
      token.value,
      token.startLine,
      token.startColumn
    )
  end

  function parser:unexpectedEndOfInput()
    self:parseError("Unexpected end of input.")
  end

  function parser:parseError(message)
    error(message)
  end

  return parser
end

local M = {}
M.new = yyparse

return M